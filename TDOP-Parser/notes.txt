
Implementing a Top Down Recursive Decent Parser AKA Pratt Parsing

NOTES: 

	- Hard code the tokens for now - main focus is to parse to a nice data structure
	- Tokens -> Specific Class Object that implements interface 'Expression' - used for pretty printing
	- Multiple subclasses implement the Expression interface. Eg ConditionalExpression
	- The entire purpose of using a vector is to push back values known at runtime
	  Will have to read from a file of mock token list later on

Interfaces:
	- Expression : Implemented by ConditionalExpression
	- PrefixParselet : Implemented by NameParselet -> Return NameExpression, PrefixOperatorParselet -> PrefixExpression

THINGS I DON'T UNDERSTAND
	- The entire concept of top-down recursive descent parsing!
	- Token of lookahead LL(1)
	-  Registering of the infix and prefix operators into the arrayLists - will do later


GENERAL KNOWLEDGE:
	- The base class defines as virtual those functions it expects its derived classes to define for themselves.
	- Research file naming convention on different systems. Apparently the convention is to use all lowercase letters

Issue imo: Abstract class cannot be passed as an argument
How to use the override keyword?
Need to define destructor for NameExpression and others? Include 
the delete thingy too

Comment: ctrl+k+c 
UnComment: ctrl+k+u

Learned about header guards!  
Read up on polymorphism in c++ - are pointers necessary? 
Search up smart pointers as well

=0 after a virtual function override is an error! Only use =0  for the abstract class
---------------------------------

Main Implementation

Parselets:
	- Binary Operators : Implements InfixParselet (+, - , *)
	- Name			   : Implements PrefixParselet
	- Integer		   : Implements PrefixParselet

Prefix can shift into one single class....


CURRENT: Learn why the values of the pointer are not the same when we switch
		back from outside stack frame to the original... should I use static variables?

We are modifying the attributes of the parser class when we move out of the main stack frame. 
The issue: we are passing the parser class by value and NOT by reference. This means that the value is copied 
into the other stack frame from the changes made are not universal since it does not affect the address of the 
parser object directly!